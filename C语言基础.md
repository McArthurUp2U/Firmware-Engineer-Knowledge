C语言基础
===============

## **数据类型与运算符**
###变量名
* 变量名由字母与数字组合而成，必须由字母开头，下划线_视为字母。
* 变量使用小写，常量使用大写。

###数据类型  
* C语言只提供下面几种数据类型
|类型|说明|
|:-----|:----|
|char  |字符型:占用一个字节|
|int   |整形,通常反映所在机器整数的最自然的长度|
|float |单精度浮点型|  
|double|双精度浮点型|  


* short与long 
    short与int类型至少16位，long类型至少为32位，且short类型不得长于int类型,int类型不得短与long.
一个典型的32位处理器上各数据长度如下：
|类型|长度（字节）|
|:----:|:-----:|
|char     |1|
|int      |4|
|short    |2|
|long     |4|
|long long|8|


* unsigned 与signed
    unsigned:无符号数，编码范围0 到 (2^w - 1)
    signed(默认):补码编码，编码范围 -(2^(w-1))到(2^(w-1)-1)

##枚举常量
枚举默认从零开始，第二个为1，依次递增
```C
enum{
    NO,
    YES
}
```

##类型转换
* 算术运算式中，低类型将转换为高类型
**优先级**
    ![](https://img-blog.csdn.net/20170616200811277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUUNaVFpTV1QzNTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
* 赋值运算符中，右边表达式的值自动隐式转换为左边变量的值
* 函数调用中参数的传递，系统隐式的将实参转为形参的类型，赋给形参
* 函数有返回值时，系统隐式的将返回表达式的值转换为返回值类型

##位运算
|运算符|作用|
|:-----:|:-----:|
| &  |按位与|
| \|  |按位或|
| ^  |按位异或|
| << |左移|
| \>> |右移|
| ~  |按位取反|

*常用技巧
1. 取一个数的指定位
```C
    unsigned char a = 0xF3;
    a &= 0x0F;//取低4位
```
2.对数据某位置1
```C
    unsigned char a = 0xF3;
    a |= 0x08;//第4位置1
```
3.对数据某位置0
```C
    unsigned char a = 0xF3;
    a &= ~0x08;//第4位置0
```
4.某1位置0或1
```
    #define setbit(X,Y) X |= (1<<Y)
    #define clrbit(X,Y) X &= ~(1<<Y)
```

##**数组与指针**
###指针基础
* 指针:**指针就是程序数据在内存中的地址，指针变量就是用来保存这些地址的变量,指针变量占据内存空间与系统有关，为sizeof(void*)**

###各类型指针
```C
    int *p;          //指向int的指针
    int **p;         //二重指针，指向指向int类型的指针
    int *p[10];      //指针数组，数组的元素均为指向int类型指针
    int (*p)[10];    //数组指针，指向一个包含10个int元素的数组
    int *fun(void);  //fun函数，参数为void,返回值为指向int类型指针
    int (*fun)(void);//函数指针，指向一个参数为void,返回值为int的函数
```

###二维数组与指针
* 基础
  * 多维数组本质上是采用一维数组模拟出来的
  * 数组名是一个常量，代表数组首元素的首地址
  * 数组是连续排布的，例:a[2][3]等价于*(*(a+2)+3)
  * 对数组名进行取地址操作(&)，类型为数组类型,例:int a[2][3];int (*p)[2][3] = &a;
  * 对数组名进行sizeof操作，返回值为整个数组大小。
  * 数组作为函数参数时会退化为指针。

* 实例
```C
    int a[2][3]={{1,2,3},{a,b,c}};
    int (*p)[3] = a;        //a为二维数组的首元素的首地址，指向一个包含3个int元素的数组。
    int (*p1)[2][3] = &a;   //对a取地址，代表是二维数组的地址类型，即int (*)[2][3];
    int *p2 = a[0];         //a[0]相当于一维数组名，即首元素的地址
    int (*p3)[3] = &a[0];   //对一维数组名取地址，代表是一维数组的地址类型，即int (*)[3];
    int *p4 = &a[0][0];     //对int类型取地址
    int p5 = a[0][0];       //int 类型
```

* 函数指针的应用---回调(callback)  
    * 回调定义:提供方提供相应的方法，在特定的事件或条件发生时，另一方进行调用，在C语言中通过函数指针作为参数传递来实现。
    * 实例
        * 排序

##**结构**
###结构体
* 定义 : 结构是一个或多个变量的集合，这些变量可以为不同的类型。
* 一般形式:
```
    struct Student
    {
        int age;
        char* name;
    };
```
* 三种定义方法
```
    //先定义结构体类线，再定义结构体变量
    struct Student
    {
        int age;
        char* name;
    };
    struct Student Bob;
    
    //同时定义结构体类型与变量
    struct Student
    {
        int age;
        char *name;
    }Bob;
    
    //直接定义结构体变量
    struct 
    {
        int age;
        char *name;
    }Bob;
    //结构体类型不分配内存，结构体变量是分配内存的。
```
###字节对齐
* 定义:现代计算机中，各中类型数据是按照一定规律在内存空间中排列，而不是顺序的一个接一个排放。
* 意义
    * 不同的硬件对存储空间的处理存在不同，某些平台对特定类型的数据只能从特定的地址开始读取。
    * 合理的内存对齐可以提升访问效率。
* 结构体对齐的原则
    * **指定对齐值，以指定对齐值为准**
    * **结构体变量的首地址能够被其最宽基本类型成员的大小整除**
    * **结构体每个成员相对结构体首地址的偏移量都是该成员大小的整数倍**
    * **结构体的总大小为结构体最宽基本类型成员大小的整数倍**
eg:
```
    typedef struct{
        char a;
        short b;
        char c;
        int d;
        char e[3];
    }T_Test;
    sizeof(T_Test);//16
    偏移    a = 0   b = 2
            c = 4   d = 8
            e[1] = 12
```
* 手动更改对齐方式
    * #pragma pack(n):编译器按照n个字节对齐
    * #pragma pack():编译器取消自定义字节对齐方式


###typedef
* 定义及功能
typedef声明本质上并没有创建一个新类型，只是为已有类型增加了一个新的名称。类似于#define ,不过typedef由编译器解释。
* 常用方法
```
    //可移植性要求
    typedef unsigned char INT8U;
    typedef signed   char INT8S;
                ...
    //结构体
    typedef struct tnode
    {
        char *name;
        struct tnode *left;
        struce tnode *right;
    }Treenode;//Treenode结构
    typedef struct tnode * Treeptr;//Treeptr:指向Treenode结构的指针
    //函数指针
    typedef void* (*Fun)(void*);//Fun:一个返回值为void*,参数为void*类型的函数指针类型。
```
### [位字段](https://blog.csdn.net/lovecodeless/article/details/23270911 "位字段博客")
* 定义
    若空间资源很宝贵，可以用位字段来代替标志位集合，可以将多个数据保存在一个机器字中。
```C
    struct
    {
	    unsigned a:20;
	    unsigned:0;  //0字段，表示下一位字段在下一个机器字边界
	    unsigned c:2;
    }flags;    
```  
* 注意事项
    * 位字段只能使用int,unsigned int,signed int 三种类型。
    * 位字段需要注意使用范围，位数决定范围
    * 位字段通过.号进行访问，如flags.a,位字段没有独立的地址，不能取址操作，不能sizeof操作
    * 位字段按声明顺序在机器字内存储，位字段不能跨越机器字存储，上一个机器字空间不足，该字段全部存在下一个机器字

### 结构与联合的区别
* 区别
    * 在结构体中，各成员变量有自己的内存空间，一个结构体变量的总长度是各成员长度之和。
    * 在联合体中，各成员变量共享一段内存空间，一个联合体变量的长度等于各成员中最长的长度。
    * 联合体中，每次只能对一个成员赋值，对其赋值后，则原有成员的值就会失效。  


### 结构的应用实例
* 链表
* 队列
* 栈
* 二叉树

##**宏定义及预处理器**
* 定义
    * 预处理器是编译过程中单独执行的第一个步骤
    * 宏仅仅是在C预处理阶段的一种简单替换
* 文件包含
`#include"  "`
`#include<  >`

* 宏替换
`#define 名字 替换文本`  
    * 标识符别名
```
    #define BUFFER_SIZE 1024
    //宏体换行需要在行末加反斜杠\
    #define NUMBERS 1,\
                    2,\
                    3
```  
* 宏函数
`宏名之后带括号的宏被认为是宏函数，在预处理阶段，宏函数会被展开。相较于普通函数，执行效率会提高，但代码体积大，没有语法检查，更危险`

    * 注意问题:完全替换，不做语法检查，需注意以下情况
        1.运算符优先级，完全替换，最好加上小括号如`#define ADD(x,y) ((x)+(y))`  
        2.分号吞噬:宏函数使用循环时，建议使用do while,不使用for,while;
        3.宏参数重复调用,若宏函数如`#define min(X,Y) ((X) < (Y) ? (X) : (Y))`,则调用`min(x+y,foo(z))`时，会展开成`((x+y) < (foo(z)) ? (x+y) : (foo(z))),foo函数被执行两次，
        4.对自身的递归调用，宏只会展开一次。若`#define foo(4+foo)`，`foo`展开后为`4+foo`,foo不会被识别。
        
* 条件包含
    * 避免头文件重复包含
    `#ifndef XXX_H`
    `#define XXX_H`
    * 条件编译，可利用宏适应多环境，可以配置DEBUG
```
    //条件编译
    #define CPU_A
    //#define CPU_B
    #if define CPU_A
        CPU_A(XXXXX);
    #elif define CPU_B
        CPU_B(XXXXX);
    #else
        CPU_O(XXXXX);
    #endif
    //DEBUG
    #define DEBUG
    #if define DEBUG
        DEBUG(XXXXX);
    #endif
```

##**const static volatile register**
* const
    * 定义:关键字const是用来定义常量的，如果一个变量被const修饰，那么他的值就不能被修改。
    * 优点
        * 可以保护被修饰的变量，防止被意外修改，增加程序健壮性。
        * 编译器优化(保存在符号表中)，提高效率
    * 典型用法
        * 修饰局部变量，n的值不可改变。
        `const int n = 5;`
        `int const n = 5;`
        * 修饰常量字符串,确保在s[1]赋值时，编译报错。
        `const char* s = "abcdefg;"`
        * 常量指针：指针指向的内容是常量
        `const int * p;`
        `int const * p;`
            * 常量指针不能通过该指针改变变量的值，但是可以通过其他方式改变变量的值  
            * 常量指针指向的内容不能改变，但可以改变指针本身的值。
            
            ```
                int a = 1;
                int b = 2
                const int *p = &a;
                a = 3;
                p = &b;
            ``` 
        * 指针常量: 指针本身为常量，不能指向其他地址。
        `int *const p;`
            * 指针常量本身指向的地址不能变，但是该地址中的值是可以改变的
            
            ```
                int a = 0;
                int *const p = &a;
                *p  = 5;
            ```
        * 指向常量的常指针:指针本身不可以修改，指向的值也不可以修改，但是可以通过其他指针改变变量的值
            `const int *const p`
            
        * 修饰参数
            * 防止指针指向的内容被修改 
            `void cmp(const char *s1,const char *s2)`
            * 防止修改指针指向的地址 
            `void swap(int *const p1,int *const p2)`
        * 修饰返回值：如果返回值为常量指针，则只能赋值给相同类型的常量指针。
        `const char * GetString(void);`
        * 修饰全部变量:防止全局变量被修改。
        

* static
    * 修饰局部变量
        * 被static修饰的局部变量不放在栈内存中，放在静态存储区。所以不会随着函数调用结束被释放。
        * static 局部变量只会在第一次时被初始化，且只能初始化1次，未初始化则默认为0；
    * 修饰全局变量与函数
        * 被static 修饰的全局变量及函数只能在当前的源文件中访问，可以隐藏数据，降低系统耦合。
    
* volatile
    * volatile修饰的变量代表其会直接从内存中重新装载数据，而不是从寄存器中拷贝内容。
    * 在部分情况下，变量的值可能会被意想不到的改变，例如中断中的变量或硬件寄存器的值，但是由于编译器优化，程序可能仍然读取寄存器中的拷贝，为了确保每次读写都从源地址读取，需要采用volatile修饰。
* register
    * 数据直接存贮在寄存器中，需要访问时，不需要在RAM中寻址，直接寄存器寻址，速度快，可以提高运行效率。
    * 数据放在寄存器中，不能对register变量进行取地址(&)操作。

    
  



